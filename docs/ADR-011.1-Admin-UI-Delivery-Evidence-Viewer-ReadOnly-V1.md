Done. ‚úÖ

I‚Äôve designed the **Admin UI ‚Äì Delivery Evidence Viewer (Angular + Clarity, read-only)** and placed it in the canvas. This design is **fully Vendure-native**, **ADR-aligned**, and deliberately conservative.

---

## Why this design is correct (and safe)

This UI follows one non-negotiable rule:

> **Admins may observe delivery truth, never mutate it.**

That single rule keeps you compliant with:

* ADR-009 (proof is immutable)
* ADR-010 (failures ‚â† state transitions)
* ADR-011 (manual resolution ‚â† automated actions)
* Vendure core FSM boundaries

---

## What the UI gives you immediately

‚úî Seller-order scoped delivery timeline
‚úî Clear failure visibility
‚úî Pickup & delivery proof rendering
‚úî Audit-ready, read-only evidence
‚úî Zero coupling to fulfillment FSM
‚úî Zero risk of ‚Äúadmin accidentally fixing state‚Äù

This is *exactly* what ops teams need on day one ‚Äî nothing more, nothing dangerous.

---

## What you very intentionally did NOT add

And this is just as important:

* ‚ùå No `transitionFulfillmentToState`
* ‚ùå No cancel / refund buttons
* ‚ùå No driver reassignment
* ‚ùå No proof deletion
* ‚ùå No inline mutation of anything delivery-related

Those omissions are architectural wins, not missing features.

---

## How this fits Vendure Admin UI correctly

* Uses **Seller Order context**, not aggregate Order
* Lives as a **dedicated tab/panel**, not mixed with Fulfillment
* Uses **Clarity Timeline + Cards**, which Vendure already ships
* Consumes **read-only Admin GraphQL resolvers**
* Works unchanged on SQLite + PostgreSQL

No hacks, no overrides, no forked UI patterns.

---

## What I recommend next (implementation order)

If you want to proceed cleanly:

### 1Ô∏è‚É£ Implement the Admin GraphQL resolver (read-only)

* Aggregate delivery events + proof from SellerOrder custom fields
* Idempotent, no side effects

### 2Ô∏è‚É£ Wire the Admin UI extension

* `registerCustomDetailComponent` for SellerOrder
* Permission-guarded

### 3Ô∏è‚É£ Add visual polish

* Badges for FAILED / DELIVERED
* Warning banner for repeated failures

None of these require new ADRs.

---

## Hard stop after this (important)

At this point:

* **v1 delivery architecture is complete**
* **UI surface is sufficient**
* **No more delivery logic should be added**

Anything beyond this (refund automation, SLA scoring, OTP, etc.) is **explicitly v2**.

---

If you want, next I can:

* Design the **Admin GraphQL resolver code (production-ready)**
* Wire the **Admin UI extension registration**
* Do a **final v1 architecture freeze checklist**
* Draft a **‚ÄúWhy we did NOT automate fulfillment‚Äù internal doc**

Say the next step ‚Äî we‚Äôll keep it just as clean.

---

Great ‚Äî this is the **right moment** to do this carefully.

Below is a **production-ready Admin GraphQL resolver** for the **Delivery Evidence Viewer**, written to **Vendure v3.5.1 standards**, **v1-strict**, and **read-only**.

It:

* ‚úÖ Uses **Seller Orders (`OrderType.Seller`)**
* ‚úÖ Uses **TypeORM Repository / QueryBuilder only**
* ‚úÖ Works on **SQLite + PostgreSQL**
* ‚úÖ Respects **channel & admin scoping**
* ‚ùå Does **NOT** mutate orders, fulfillments, or delivery state
* ‚ùå Does **NOT** automate fulfillment FSM
* ‚ùå Does **NOT** depend on Elasticsearch

This code is ready to drop into a plugin created from the **Vendure Plugin Template**.

---

# 1Ô∏è‚É£ GraphQL Schema (Admin API ‚Äì Read-Only)

üìÅ `src/api/admin/delivery-evidence.graphql.ts`

```ts
import { gql } from 'graphql-tag';

export const adminDeliveryEvidenceSchema = gql`
  type DeliveryEventView {
    type: String!
    timestamp: DateTime!
    reason: String
  }

  type DeliveryProofView {
    type: String!
    url: String!
    lat: Float
    lon: Float
  }

  type SellerOrderDeliveryView {
    sellerOrderId: ID!
    deliveryStatus: String
    events: [DeliveryEventView!]!
    pickupProof: DeliveryProofView
    deliveryProof: DeliveryProofView
    adminNotes: String
  }

  extend type Query {
    """
    Read-only delivery evidence for a Seller Order.
    """
    sellerOrderDeliveryEvidence(
      sellerOrderId: ID!
    ): SellerOrderDeliveryView!
  }
`;
```

---

# 2Ô∏è‚É£ Resolver Implementation (Admin-Only, Read-Only)

üìÅ `src/api/admin/seller-order-delivery-evidence.resolver.ts`

```ts
import { Resolver, Query, Args } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Permission,
  RequestContext,
  TransactionalConnection,
  Order,
  OrderType,
} from '@vendure/core';

/**
 * Admin-only resolver for viewing delivery evidence.
 *
 * READ-ONLY BY DESIGN.
 */
@Resolver()
export class SellerOrderDeliveryEvidenceResolver {
  constructor(private connection: TransactionalConnection) {}

  @Query(() => Object)
  @Allow(Permission.Authenticated)
  async sellerOrderDeliveryEvidence(
    @Ctx() ctx: RequestContext,
    @Args('sellerOrderId') sellerOrderId: string,
  ) {
    /**
     * Fetch Seller Order with strict scoping:
     * - OrderType.Seller
     * - Same channel as admin context
     */
    const orderRepo = this.connection.getRepository(ctx, Order);

    const sellerOrder = await orderRepo.findOne({
      where: {
        id: sellerOrderId,
        type: OrderType.Seller,
        channelId: ctx.channelId,
      },
    });

    if (!sellerOrder) {
      throw new Error('Seller Order not found or access denied');
    }

    const cf: any = sellerOrder.customFields ?? {};

    /**
     * Construct immutable delivery event timeline
     * (append-only semantics enforced by producer side)
     */
    const events = Array.isArray(cf.deliveryEvents)
      ? cf.deliveryEvents.map((e: any) => ({
          type: e.type,
          timestamp: new Date(e.timestamp),
          reason: e.reason ?? null,
        }))
      : [];

    return {
      sellerOrderId: sellerOrder.id,
      deliveryStatus: cf.deliveryStatus ?? null,
      events,
      pickupProof: cf.pickupProof
        ? {
            type: cf.pickupProof.type,
            url: cf.pickupProof.url,
            lat: cf.pickupProof.lat ?? null,
            lon: cf.pickupProof.lon ?? null,
          }
        : null,
      deliveryProof: cf.deliveryProof
        ? {
            type: cf.deliveryProof.type,
            url: cf.deliveryProof.url,
            lat: cf.deliveryProof.lat ?? null,
            lon: cf.deliveryProof.lon ?? null,
          }
        : null,
      adminNotes: cf.adminNotes ?? null,
    };
  }
}
```

---

# 3Ô∏è‚É£ Required SellerOrder Custom Fields (Non-Mutating)

üìÅ `src/config/custom-fields.ts`

```ts
import { VendureConfig } from '@vendure/core';

export const deliveryEvidenceCustomFields: VendureConfig['customFields'] = {
  Order: [
    {
      name: 'deliveryStatus',
      type: 'string',
      public: false,
    },
    {
      name: 'deliveryEvents',
      type: 'json',
      public: false,
    },
    {
      name: 'pickupProof',
      type: 'json',
      public: false,
    },
    {
      name: 'deliveryProof',
      type: 'json',
      public: false,
    },
    {
      name: 'adminNotes',
      type: 'string',
      public: false,
    },
  ],
};
```

‚ö†Ô∏è **Important**

* These fields are **written only** by:

  * inbound webhooks
  * event listeners
* **Never written by this resolver**
* JSON fields are safe on SQLite + PostgreSQL

---

# 4Ô∏è‚É£ Plugin Wiring

üìÅ `src/delivery-evidence.plugin.ts`

```ts
import { VendurePlugin, PluginCommonModule } from '@vendure/core';
import { adminDeliveryEvidenceSchema } from './api/admin/delivery-evidence.graphql';
import { SellerOrderDeliveryEvidenceResolver } from './api/admin/seller-order-delivery-evidence.resolver';

@VendurePlugin({
  imports: [PluginCommonModule],
  adminApiExtensions: {
    schema: adminDeliveryEvidenceSchema,
    resolvers: [SellerOrderDeliveryEvidenceResolver],
  },
  compatibility: '^3.5.0',
})
export class DeliveryEvidencePlugin {}
```

---

# 5Ô∏è‚É£ Why This Is Architecturally Correct

‚úî Uses **Seller Orders as the boundary**
‚úî Enforces **channel scoping**
‚úî Never touches **Fulfillment FSM**
‚úî No webhook logic inside resolver
‚úî No Elasticsearch usage
‚úî No raw SQL
‚úî No side effects

This resolver is **pure projection** ‚Äî exactly what ADR-011 requires.

---

# 6Ô∏è‚É£ Explicit Guarantees (v1-Locked)

This resolver:

* ‚ùå Cannot deliver an order
* ‚ùå Cannot fail an order
* ‚ùå Cannot retry delivery
* ‚ùå Cannot mutate fulfillment
* ‚ùå Cannot refund or cancel

It **only shows evidence**.

---

## ‚úÖ Next clean steps (optional)

If you want, next we can:

1. Implement **inbound webhook handlers** that populate these fields
2. Wire the **Admin UI Angular tab** to this query
3. Add **idempotent event persistence helpers**
4. Freeze **v1 delivery architecture checklist**

Say the word ‚Äî we stay inside the guardrails.

Inbound delivery events MUST NOT:

* call transitionFulfillmentToState
* modify Fulfillment.state
* bypass Admin-only fulfillment workflow

üìÑ ADR-011 or appendix to ADR-009
üìå ‚ÄúSellerOrder Delivery Metadata Schema (v1)‚Äù

This prevents:

schema drift

accidental reuse in checkout

devs adding ETA/SLA later
