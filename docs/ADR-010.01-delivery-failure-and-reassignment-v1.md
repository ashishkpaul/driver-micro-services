Done. âœ…

Iâ€™ve **carefully studied your FulfillmentProcess / driver-side automation reference**, and **ADR-010 has been drafted accordingly** â€” with an explicit, intentional decision to **reject Fulfillment FSM automation in v1** while staying 100% compliant with Vendure core architecture and your existing ADR stack.

### Why this is the *correct* outcome (and not a dodge)

You are absolutely right about Vendureâ€™s capabilities:

* Vendure **does** support automated fulfillment transitions via `FulfillmentProcess`
* A driver app **can** technically call `transitionFulfillmentToState`
* Many teams *do* use this to auto-mark deliveries as `Delivered`

However â€” and this is the key architectural insight â€” **capability â‰  correctness for your system**.

### What ADR-010 intentionally locks

ADR-010 makes a **deliberate architectural choice**:

#### ğŸš« In v1, driver systems MUST NOT

* Call `transitionFulfillmentToState`
* Trigger `Shipped â†’ Delivered`
* Act as authorities over Vendureâ€™s FSM
* Be wired via `FulfillmentProcess`

#### âœ… Instead, driver systems

* Emit **facts** (`DELIVERY_FAILED_V1`, `DELIVERY_PICKED_UP_V1`, `DELIVERY_DELIVERED_V1`)
* Own retries, reassignment, and escalation
* Provide **proof**, not state transitions

Vendure:

* Records delivery facts
* Remains passive and auditable
* Never becomes a logistics orchestrator

This **directly preserves**:

* ADR-005 (Delivery separation)
* ADR-006 (event facts, not workflows)
* ADR-009 (proof > inference)
* Checkout and payment correctness

---

### Why using `FulfillmentProcess` here would be a mistake (for *your* platform)

Even though Vendure allows it, using `FulfillmentProcess` for driver automation would:

1. **Couple delivery uptime to commerce correctness**
2. Create ambiguous ownership of â€œdeliveredâ€
3. Break future multi-leg / partial delivery
4. Force refunds, disputes, and SLAs into the FSM
5. Turn Vendure into something it is not designed to be:
   ğŸ‘‰ a real-time logistics engine

ADR-010 prevents that drift **before it happens**.

---

### What you now have (architecturally)

With ADR-010 in place, your delivery stack is:

```
Vendure
  â”œâ”€ Seller Orders (truth)
  â”œâ”€ Inventory & payment (final)
  â”œâ”€ Delivery facts (read-only)
  â””â”€ Admin visibility

Driver Service
  â”œâ”€ Dispatch
  â”œâ”€ Retry & reassignment
  â”œâ”€ Failure handling
  â”œâ”€ Proof capture
  â””â”€ Operational control
```

This is **exactly** how large marketplaces evolve safely.

---

### Whatâ€™s the *next* clean step (no guessing)

Now that failures are defined, the **only remaining gap** is human operations.

#### ğŸ”œ Recommended next ADR

**ADR-011: Admin Dispute, Escalation & Manual Resolution**

That ADR would define:

* How ops handle repeated failures
* When refunds are allowed
* How proof is reviewed
* What actions are *explicitly manual*

No code changes required â€” just governance.

If you want, I can:

* Draft ADR-011 next
* Or cross-review **ADR-005 â†’ ADR-010** for any wording risks
* Or design the **Admin UI evidence viewer** (Angular + Clarity, read-only)

Youâ€™re building this the *right* way.
Say the next step.

Vendure MUST ignore any inbound delivery event if:

* sellerOrderId already has a terminal deliveryStatus
* OR the same event type was previously recorded

Inbound delivery events MUST NOT:

* call transitionFulfillmentToState
* modify Fulfillment.state
* bypass Admin-only fulfillment workflow

On DELIVERY_FAILED_V1:

* Vendure records failure metadata
* Vendure DOES NOT:
  * cancel SellerOrder
  * refund payment
  * retry delivery
  * notify customer automatically
